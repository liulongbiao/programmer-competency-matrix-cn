# 编程

| | 2<sup>n</sup>(level 0) | n<sup>2</sup>(level 1) | n (level 2) | log(n) (level 3) |
| -- | -- | -- | -- | -- |
| 问题分解 | 仅通过复制粘贴代码来进行重用 | 能将问题分解为多个函数 | 能提供解决整体问题的可重用函数/对象 | 使用合适的数据结构和算法<br/>能提供通用/面向对象的代码来封装问题中会变化的方面 |
| 系统分解 | 无法从单个文件/类以上的高度来思考 | 能够在**相同的平台/技术**内拆分问题空间及设计解决方案 | 能够设计跨多种技术/平台的系统 | 能够可视化并设计带有多个产品线的复杂系统及其与外部系统的集成<br/>同时能够设计运维支持系统如监控、报告、故障恢复等 |
| 沟通 | 无法给同事表达想法/意见<br/>拼写和语法较差 | 同事可以理解说的是什么<br/>良好的拼写和语法 | 能和同事有效地沟通 | 能够以清晰的方式理解和沟通观点/设计/意见/规范<br/>并根据不同的上下文调整沟通方式 |


> **沟通** 在评价一个程序员时是常常被低估的一项。
> 随着编程任务被外包给非英语母语地区变得越来越多，这个问题会更加突出。
> 我了解到很多项目因为程序员无法理解沟通的是什么而导致项目失败。

| | 2<sup>n</sup>(level 0) | n<sup>2</sup>(level 1) | n (level 2) | log(n) (level 3) |
| -- | -- | -- | -- | -- |
| 文件内代码组织 | 没有文件内代码组织的迹象 | 方法根据逻辑或访问性进行分组 | 代码按区块分组<br/>并且具有到其它源码文件的良好的注释 | 文件包含许可证头部、摘要，有良好的注释和一致的空格使用。<br/>文件应该看起来漂亮 |
| 跨文件代码组织 | 不考虑跨文件代码组织 | 相关文件用目录来分组 | 每个物理文件都具有唯一的目的，<br/>如一个类定义<br/>一个特性实现等 | 物理层的代码组织紧紧匹配设计<br/>且查看目录和文件名称可以洞察其设计 |
| 源码树组织 | 所有东西都在一个目录中 | 基本分离代码到逻辑目录中 | 没有循环依赖<br/>二进制包、类库、文档、构件、第三方代码都组织到合适的目录中 | 物理源码树布局匹配逻辑层级并组织。<br/>目录名称和组织提供了对系统设计的洞察 |

> 这两者差别在于组织的尺度上，源码树组织关系到定义整个系统的工件集

| | 2<sup>n</sup>(level 0) | n<sup>2</sup>(level 1) | n (level 2) | log(n) (level 3) |
| -- | -- | -- | -- | -- |
| 代码可读性 | 单音节名称 | 对文件、变量、类、方法有良好的命名 | 没有过长的函数<br/>注释解释了不寻常的代码、BUG 修复、代码假设等 | 代码假设由 asset 来验证<br/>代码流自然 - 没有深度嵌套的条件或方法 |
| 防御编程 | 不理解这个概念 | 在代码中检查所有参数和 assert 重要假设 | 确保检查返回值以及检查可能失败的代码的异常 | 有自己的类库来帮助防御编程<br/>编写单元测试来模拟错误 |